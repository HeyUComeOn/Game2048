#include "GameScene.h"
#include "GameDefine.h"
#include "MovedTile.h"
#include "Dlog.h"
USING_NS_CC;

GameScene::GameScene()
{
}

GameScene::~GameScene()
{
}

Scene* GameScene::createScene()
{

	auto scene = Scene::create();


	auto layer = GameScene::create();


	scene->addChild(layer);


	return scene;
}


bool GameScene::init()
{
	//////////////////////////////
	// 1. super init first
	if ( !Layer::init() )
	{
		return false;
	}

	auto labelGame = Label::createWithBMFont("fonts/futura-48.fnt","2048");
	labelGame->setPosition(labelGame->getContentSize().width/2 ,
		GAME_SCREEN_HEIGHT-labelGame->getContentSize().height/2);
	labelGame->setScale(0.5f);
	addChild(labelGame);

	//创建背景网格
	auto backWidth = GAME_TILE_WIDTH*GAME_COLS+GAME_TILE_GAP*(GAME_COLS+1);
	auto backHeight = GAME_TILE_HEIGHT*GAME_ROWS+GAME_TILE_GAP*(GAME_ROWS+1);
	colorBack = LayerColor::create(Color4B(170,170,170,255),backWidth,backHeight);
	//colorBack->setAnchorPoint(Vec2(0.5,0.5));锚点无法更改bug
	colorBack->setPosition(GAME_SCREEN_WIDTH/2 - backWidth/2,GAME_SCREEN_HEIGHT/2-backHeight/2) ;
	addChild(colorBack);

	//初始化网格的每一个块
	for (int row = 0; row<GAME_ROWS; row++)
	{
		for(int col = 0; col<GAME_COLS; col++)
		{
			auto layerTile = LayerColor::create(Color4B(70,70,70,255),GAME_TILE_WIDTH,GAME_TILE_HEIGHT);

			layerTile->setPosition(GAME_TILE_WIDTH*col+GAME_TILE_GAP*(col+1), GAME_TILE_HEIGHT*row+GAME_TILE_GAP*(row+1));
			
			colorBack->addChild(layerTile);
		}
		
	}
	//初始化"逻辑的网格"数组
	for(int i= 0;i<GAME_ROWS;i++)
	{
		for(int j = 0;j<GAME_COLS;j++)
		{
			map[i][j] = 0;//空白
		}
	}
	//初始化数字块
	newMoveTile();
	
	//触摸的处理
	auto event = EventListenerTouchOneByOne::create();
	event->onTouchBegan = [&](Touch*tou,Event* event){
		m_x = tou->getLocation().x;
		m_y = tou->getLocation().y;
		m_startMove = true;
		return true;
	};
	event->onTouchMoved = [&](Touch*tou,Event* event){
		int x = tou->getLocation().x;
		int y = tou->getLocation().y;
		if(m_startMove && (abs(m_x - x)>10||abs(m_y - y)>10))
		{
			m_startMove = false;
			E_MOVE_DIRECT direct;
			if(abs(m_x - x)>abs(m_y - y))
			{
				if (m_x<x)
				{
					direct = E_MOVE_DIRECT::RIGHT; 
				}
				else
				{
					direct = E_MOVE_DIRECT::LEFT;
				}
			}
			else
			{
				if(m_y<y)
				{
					direct = E_MOVE_DIRECT::UP;
				}
				else{
					direct = E_MOVE_DIRECT::DOWN;
				}
			}
			moveAllTile(direct);//所有的元素块
		}
	};
	Director::getInstance()->getEventDispatcher()->addEventListenerWithSceneGraphPriority(event,this);
	//分数

	return true;
}

void GameScene::moveAllTile(E_MOVE_DIRECT direct)
{
	//移动所有块,消除
	switch (direct)
	{
	case E_MOVE_DIRECT::UP:
		moveUp();
		break;
	case E_MOVE_DIRECT::DOWN:
		moveDown();
		break;
	case E_MOVE_DIRECT::LEFT:
		moveLeft();
		break;
	case E_MOVE_DIRECT::RIGHT:
		moveRight();
		break;
	default:
		break;
	}
	//播放音乐
	//判定输赢
	//产生新块
	newMoveTile();
}

void GameScene::newMoveTile()
{
	auto tile = MovedTile::create();
	int freeCount = 16-m_allTile.size();
	if(freeCount==0)//没有空白区域
	{
		Dlog::showLog("no Space");
		return;
	}
	int num = rand()%freeCount;
	//检测再次添加时会不会重叠，此处只要空白数
	int row = 0;
	int col = 0;
	int count = 0;
	bool find = false;
	for (;row<GAME_ROWS;row++)
	{
		for (col = 0;col<GAME_COLS;col++)//此处加上col=0
		{
			if(map[row][col]==0)
			{
				count++;//记录空白的数量
				if(count >= num)//由==改为>=
				{
					find = true;
					break;
				}
			}
		}
		if(find)
		{
			break;
		}
	}
	tile->moveTo(row, col);
	colorBack->addChild(tile);
	m_allTile.pushBack(tile);
	//此为核心数据结构，表示有m_allTile.getIndex(tile)+1个可移动得块
	map[row][col] = m_allTile.getIndex(tile)+1;//表示有m_allTile.getIndex(tile)个可移动得块
	Dlog::showLog("%d,%d",row,col);
}

void GameScene::moveUp()//从此看起
{
	//移动所有的块
	for (int col = 0;col<GAME_COLS; col++)
	{
		for (int row = GAME_ROWS-1;row>=0;row--)//row>0改为row>=0
		{
			if (map[row][col]>0)
			{
				for (int row1 =row;row1<GAME_ROWS-1;row1++)
				{
					if(map[row1+1][col]==0)
					{
						map[row1+1][col] = map[row1][col];
						map[row1][col] = 0;
						m_allTile.at(map[row1+1][col]-1)->moveTo(row1+1,col);
					}else
					{
						break;
					}
				}
			}
		}
	}
}

void GameScene::moveDown()
{
	
}

void GameScene::moveLeft()
{

}

void GameScene::moveRight()
{

}